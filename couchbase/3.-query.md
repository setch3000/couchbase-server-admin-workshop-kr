# 3. Query 최적화

쿼리에 지정된 모든 필드의 실제 값이 인덱스에 포함되어 있을 때, 해당 인덱스는 쿼리를 **커버(Cover)**&#xD55C;다고 하며 데이터 서비스로부터 실제 값을 가져오는 추가 단계(Fetch)를 거치지 않습니다. 이 경우의 인덱스를 **커버링 인덱스(Covering Index)**&#xB77C; 부르고, 해당 쿼리를 **커버드 쿼리(Covered Query)**&#xB77C;고 합니다. 결과적으로 커버드 쿼리는 속도가 더 빠르며 더 나은 성능을 제공합니다.

금번에는 이러한 커버드 쿼리(Covered Query) 실습을 진행합니다.





### 커버드 쿼리(Covered Query) 실습 #1

먼저 Operational Clusters / Data Tools > Query를 선택합니다. 그런 다음 아래 쿼리를 사용하여 Covering Index를 먼저 생성합니다.

```sql
CREATE INDEX idx_flight_covering
ON `travel-sample`(
    sourceairport,
    destinationairport,
    utc_departure,
    airline
)
WHERE type = "route";
```

<figure><img src="../.gitbook/assets/image (2) (1).png" alt=""><figcaption></figcaption></figure>



인덱스 생성이 완료되면 다음 쿼리를 실행합니다.

```sql
SELECT
    sourceairport,
    destinationairport,
    utc_departure,
    airline
FROM `travel-sample`
WHERE type = "route"
  AND sourceairport = "SFO"
  AND destinationairport = "LAX"
ORDER BY utc_departure
LIMIT 20;
```



다음과 같이 쿼리 결과를 확인하실 수 있습니다.

<figure><img src="../.gitbook/assets/image (49).png" alt=""><figcaption></figcaption></figure>



Plan 탭을 클릭하여 보시면, 서비스로부터 실제 값을 가져오는 추가 단계(Fetch)를 거치지 않는 것을 확인하실 수 있습니다.

<figure><img src="../.gitbook/assets/image (1) (1).png" alt=""><figcaption></figcaption></figure>





### 커버드 쿼리(Covered Query) 실습 #2

아래 쿼리를 사용하여 Covering Index를 먼저 생성합니다.

```sql
CREATE INDEX idx_hotel_city_rating_covering
ON `travel-sample` (
 city,
 rating DESC,
 country,
 name,
 address,
 price
)
WHERE type = "hotel";
```



<figure><img src="../.gitbook/assets/image.png" alt=""><figcaption></figcaption></figure>



인덱스 생성이 완료되면 다음 쿼리를 실행합니다.

```sql
SELECT
    name,
    address,
    city,
    country,
    price,
    rating
FROM `travel-sample`
WHERE type = "hotel"
  AND city = "San Francisco"
ORDER BY rating DESC
LIMIT 10;
```



<figure><img src="../.gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>



이 쿼리의 Plan을 보시면 복합 인덱스(`idx_hotel_city_rating`)를 효과적으로 활용하여 `city`와 `rating` 조건을 인덱스 레벨에서 처리합니다. IndexScan이 82%를 차지하지만, 실제 실행 시간이 2ms로 매우 빠른 것은 인덱스가 잘 최적화되어 있음을 의미합니다.

실행 단계 (왼쪽→오른쪽)

1\) Authorize (0.8%) - 권한 확인 단계

2\) IndexScan3 (82.4%) - 가장 비용이 큰 단계

* `idx_hotel_city_rating_c...` 인덱스 사용
* 10개 문서 입력 → 10개 출력
* 전체 실행 시간의 대부분을 차지

3\) Filter (1.6%) - 조건 필터링

* `type = "hotel"` 조건 적용
* 10 in / 10 out (모든 문서가 조건 충족)

4\) Project (5.9%) - 필드 추출

* SELECT 절의 6개 필드 추출 (name, address, city, country, price, rating)

5\) Limit (0.3%) - 결과 제한

* 상위 10개로 제한

6\) Stream (8.2%) - 결과 반환

* 최종 10개 문서 출력



성능 지표

* RTT: 424ms
* 실제 실행 시간: 2ms
* 반환 문서: 10개
* 데이터 크기: 1.4KB

<figure><img src="../.gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>





수고하셨습니다.
